<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="yen.20170108171605.1"><vh>@settings</vh>
<v t="yen.20170108171605.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="yen.20170108171605.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="yen.20170108171622.1"><vh>有關 2017springcd</vh></v>
<v t="yen.20170108171733.1" a="E"><vh>@path ../</vh>
<v t="yen.20170108171733.2"><vh>@button pelican-blog</vh></v>
<v t="yen.20170108171733.3"><vh>@edit README.md</vh></v>
<v t="yen.20170108171733.4"><vh>@edit .gitignore</vh></v>
<v t="yen.20170108171733.5"><vh>Pelican 設定</vh>
<v t="yen.20170108171733.6"><vh>@edit local_publishconf.py</vh></v>
<v t="yen.20170108171733.7"><vh>@edit pelicanconf.py</vh></v>
</v>
<v t="yen.20170215103217.1"><vh>編輯 template</vh>
<v t="yen.20170215103228.1" a="E"><vh>@path theme/pelican-bootstrap3_local/templates</vh>
<v t="yen.20170215103332.1"><vh>@edit base.html</vh></v>
</v>
</v>
<v t="yen.20170120110024.1"><vh>@clean index.html</vh>
<v t="yen.20170120110024.2" a="E"><vh>html</vh>
<v t="yen.20170120110024.3"><vh>head</vh></v>
<v t="yen.20170120110024.4" a="E"><vh>body</vh>
<v t="yen.20170120110024.5" a="E"><vh>reveal div</vh>
<v t="leo.20170303213004.1" a="E"><vh>slides div</vh>
<v t="leo.20170303213004.2"><vh>封面投影片</vh>
<v t="leo.20170303213004.3"><vh>封面投影片內容</vh></v>
</v>
<v t="leo.20170303213004.4"><vh>快捷鍵</vh>
<v t="leo.20170303213004.5"><vh>投影片快捷鍵</vh></v>
</v>
<v t="leo.20170506182727.1"><vh>20170405第十週上課筆記</vh>
<v t="leo.20170506182727.2"><vh>上課內容</vh>
<v t="leo.20170506182727.3"><vh>上課大綱</vh></v>
</v>
<v t="leo.20170506182955.1"><vh>練習1-1</vh>
<v t="leo.20170506182955.2"><vh>練習</vh></v>
</v>
<v t="leo.20170506183107.1"><vh>圖片1-1</vh>
<v t="leo.20170506183107.2"><vh>練習</vh></v>
</v>
<v t="leo.20170506183215.1"><vh>練習2-1</vh>
<v t="leo.20170506183215.2"><vh>練習</vh></v>
</v>
<v t="leo.20170506183209.1"><vh>圖片2-1</vh>
<v t="leo.20170506183209.2"><vh>練習</vh></v>
</v>
<v t="leo.20170506183317.1"><vh>練習3-1</vh>
<v t="leo.20170506183317.2"><vh>練習</vh></v>
</v>
<v t="leo.20170506183320.1"><vh>圖片3-1</vh>
<v t="leo.20170506183320.2"><vh>練習</vh></v>
</v>
<v t="leo.20170506183412.1"><vh>影片</vh>
<v t="leo.20170506183412.2"><vh>練習</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="yen.20170108171733.71" a="E"><vh>@path content</vh>
<v t="leo.20170506173751.1"><vh>@edit 20170426.md</vh></v>
<v t="yen.20170108171733.81"><vh>@path pages</vh>
<v t="yen.20170108171733.82"><vh>@edit pages_1.md</vh></v>
</v>
</v>
<v t="yen.20170108171733.83"><vh>產生 .key 與 .crt</vh></v>
</v>
<v t="yen.20170108171930.1"><vh>@button https server</vh></v>
<v t="yen.20170108171939.1"><vh>@button ipv6 https server</vh></v>
<v t="yen.20170120212350.1"><vh>programs</vh>
<v t="leo.20170509173005.1" a="E"><vh>W11</vh>
<v t="leo.20170509173005.2"><vh>spur</vh></v>
<v t="leo.20170509173005.3"><vh>Cango javascript</vh></v>
<v t="leo.20170509173005.4"><vh>fillet intersection</vh></v>
<v t="leo.20170509173005.5"><vh>Involute Javascript</vh></v>
<v t="leo.20170509173005.6"><vh>animation script</vh></v>
</v>
</v>
<v t="yen.20170209024032.1"><vh>reference</vh></v>
<v t="leo.20170509172841.1" a="E"><vh>Recovered Nodes</vh>
<v t="leo.20170509172841.2"><vh>Recovered node "圖片" from @clean index.html</vh>
<v t="leo.20170509172841.3"><vh>old:圖片</vh></v>
<v t="leo.20170509172841.4"><vh>new:圖片</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20170303213004.1">&lt;!-- Any section element inside of this container is displayed as a slide --&gt;
&lt;div class="slides"&gt;
@others
&lt;/div&gt;

</t>
<t tx="leo.20170303213004.2">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="leo.20170303213004.3">## 2017Spring 協同產品設計實習

### 虎科大機械設計工程系

####學員 40423245 課程投影片

&lt;small&gt;
Created by [40423245](https://40423245.github.io/2017springcd_hw/blog/)
&lt;/small&gt;

[協同產品設計實習課程個人網誌](blog/index.html)

[Vimeo 上課心得影片](https://vimeo.com/user47996237)


</t>
<t tx="leo.20170303213004.4">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;


						
</t>
<t tx="leo.20170303213004.5"># 投影片快捷鍵

* 利用箭頭上下前後換頁
* 按 f 鍵進入全螢幕模式 (full screen)
* 按 s 鍵可以顯示投影片筆記 (show)
* 按 o 鍵可以切換單張或全域檢視 (overview)
* 按 b 或 . 鍵可以切換螢幕黑屏 (black)
* 按 Esc 可以退出全螢幕或全域檢視 (Escape)

</t>
<t tx="leo.20170506182727.1">&lt;section&gt;
@others
&lt;/section&gt;
</t>
<t tx="leo.20170506182727.2">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="leo.20170506182727.3">#第十週上課筆記

##將期中考週繪製的四連桿匯入V-rep 模擬


</t>
<t tx="leo.20170506182955.1">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="leo.20170506182955.2">##1.先將Onshape所繪製好的零件匯出成stl檔，接著匯入V-rap裡，並將各零件分解開來。




</t>
<t tx="leo.20170506183107.1">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="leo.20170506183107.2">&lt;img src="data/W10/Image W10/V-rep Divide shape.png" width="460" /&gt;



</t>
<t tx="leo.20170506183209.1">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="leo.20170506183209.2">&lt;img src="data/W10/Image W10/V-rep add Revolute .png" width="480" /&gt;



</t>
<t tx="leo.20170506183215.1">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="leo.20170506183215.2">##2.接著加入旋轉軸，與定位軸的位置重合，並將定位軸隱藏。






</t>
<t tx="leo.20170506183317.1">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="leo.20170506183317.2">##3.最後只要移好各零件與旋轉軸相對位置，即可加入馬達，將各零件實體化，就可以開始模擬了。







</t>
<t tx="leo.20170506183320.1">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="leo.20170506183320.2">&lt;img src="data/W10/Image W10/V-rep Dummy.png" width="480" /&gt;



</t>
<t tx="leo.20170506183412.1">&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
&lt;!-- 請注意, @others 不可以內縮 --&gt;
@others
    &lt;/script&gt;
&lt;/section&gt;



						
</t>
<t tx="leo.20170506183412.2">&lt;iframe src="https://player.vimeo.com/video/214997443" width="640" height="450" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href="https://vimeo.com/214997443"&gt;40423245機械設計工程系 - 協同產品設計實習課程W9-將期中考所繪製的Fourbar Walker匯入V-rep並使其作&amp;aring;&amp;lsaquo;&lt;/a&gt; from &lt;a href="https://vimeo.com/user47996237"&gt;40423245&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;



</t>
<t tx="leo.20170509172841.1"></t>
<t tx="leo.20170509172841.2">(uncached) leo.20170312212027.2
Diff...
- ####接著可利用Stop point 將路徑匯出成csv檔，接著可利用Excel裡的圖表繪製功能驗證軌跡是否相同。
?                               ^
+ ####接著可利用Stop point 將路徑匯出成csv檔 ，接著可利用Excel裡的圖表繪製功能驗證軌跡是否相同。
?                               ^
  
  &lt;img src="data/image W3/Excel trace point.png" width="560" /&gt;
  
</t>
<t tx="leo.20170509172841.3">####接著可利用Stop point 將路徑匯出成csv檔 ，接著可利用Excel裡的圖表繪製功能驗證軌跡是否相同。

&lt;img src="data/image W3/Excel trace point.png" width="560" /&gt;

</t>
<t tx="leo.20170509172841.4">####接著可利用Stop point 將路徑匯出成csv檔，接著可利用Excel裡的圖表繪製功能驗證軌跡是否相同。

&lt;img src="data/image W3/Excel trace point.png" width="560" /&gt;

</t>
<t tx="leo.20170509173005.1"></t>
<t tx="leo.20170509173005.2">&lt;canvas id='gear2' width='800' height='700'&gt;&lt;/canvas&gt;
 
&lt;script type="text/python3"&gt;
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
import math
# deg 為角度轉為徑度的轉換因子
deg = math.pi/180.
# 定義 Spur 類別
class Spur(object):
    def __init__(self, ctx):
        self.ctx = ctx
 
    def create_line(self, x1, y1, x2, y2, width=3, fill="red"):
        self.ctx.beginPath()
        self.ctx.lineWidth = width
        self.ctx.moveTo(x1, y1)
        self.ctx.lineTo(x2, y2)
        self.ctx.strokeStyle = fill
        self.ctx.stroke()
    #
    # 定義一個繪正齒輪的繪圖函式
    # midx 為齒輪圓心 x 座標
    # midy 為齒輪圓心 y 座標
    # rp 為節圓半徑, n 為齒數
    # pa 為壓力角 (deg)
    # rot 為旋轉角 (deg)
    # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷
    def Gear(self, midx, midy, rp, n=20, pa=20, color="black"):
        # 齒輪漸開線分成 15 線段繪製
        imax = 15
        # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線
        self.create_line(midx, midy, midx, midy-rp)
        # 畫出 rp 圓, 畫圓函式尚未定義
        #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2)
        # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數
        # 模數也就是齒冠大小
        a=2*rp/n
        # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍
        d=2.5*rp/n
        # ra 為齒輪的外圍半徑
        ra=rp+a
        # 畫出 ra 圓, 畫圓函式尚未定義
        #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1)
        # rb 則為齒輪的基圓半徑
        # 基圓為漸開線長齒之基準圓
        rb=rp*math.cos(pa*deg)
        # 畫出 rb 圓 (基圓), 畫圓函式尚未定義
        #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1)
        # rd 為齒根圓半徑
        rd=rp-d
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義
        #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1)
        # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小
        # 將圓弧分成 imax 段來繪製漸開線
        # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
        if rd&gt;rb:
            dr = (ra-rd)/imax
        else:
            dr=(ra-rb)/imax
        # tan(pa*deg)-pa*deg 為漸開線函數
        sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg
        for j in range(n):
            ang=-2.*j*math.pi/n+sigma
            ang2=2.*j*math.pi/n+sigma
            lxd=midx+rd*math.sin(ang2-2.*math.pi/n)
            lyd=midy-rd*math.cos(ang2-2.*math.pi/n)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(alpha-ang)
                ypt=r*math.cos(alpha-ang)
                xd=rd*math.sin(-ang)
                yd=rd*math.cos(-ang)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    lfx=midx+xpt
                    lfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # the line from last end of dedendum point to the recent
            # end of dedendum point
            # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標
            # 下列為齒根圓上用來近似圓弧的直線
            self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color)
            for i in range(imax+1):
                # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd
                if rd&gt;rb:
                    r=rd+i*dr
                else:
                    r=rb+i*dr
                theta=math.sqrt((r*r)/(rb*rb)-1.)
                alpha=theta-math.atan(theta)
                xpt=r*math.sin(ang2-alpha)
                ypt=r*math.cos(ang2-alpha)
                xd=rd*math.sin(ang2)
                yd=rd*math.cos(ang2)
                # i=0 時, 繪線起點由齒根圓上的點, 作為起點
                if(i==0):
                    last_x = midx+xd
                    last_y = midy-yd
                # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點
                self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color)
                # 最後一點, 則為齒頂圓
                if(i==imax):
                    rfx=midx+xpt
                    rfy=midy-ypt
                last_x = midx+xpt
                last_y = midy-ypt
            # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標
            # 下列為齒頂圓上用來近似圓弧的直線
            self.create_line(lfx,lfy,rfx,rfy,fill=color)
 
# 準備在 id="gear2" 的 canvas 中繪圖
canvas = doc["gear2"]
ctx = canvas.getContext("2d")
x = (canvas.width)/2
y = (canvas.height)/2
r = 0.8*(canvas.width/2)
# 齒數
n = 53
# 壓力角
pa = 20
Spur(ctx).Gear(x, y, r, n, pa, "blue")
&lt;/script&gt;</t>
<t tx="leo.20170509173005.3">&lt;canvas id='gear1' width='800' height='750'&gt;&lt;/canvas&gt;
 
&lt;script type="text/python"&gt;
# 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容
from browser import document as doc
# 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換
from browser import window
# 針對 Javascript 既有的物件, 則必須透過 JSConstructor 轉換
from javascript import JSConstructor
import math
 
# 主要用來取得畫布大小
canvas = doc["gear1"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
# 針對類別的轉換, 將 Cango.js 中的 Cango 物件轉為 Python cango 物件
cango = JSConstructor(window.Cango)
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
# 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形
# in CangoAnimation.js
#interpolate1 = window.interpolate
# Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件
cobj = JSConstructor(window.Cobj)
creategeartooth = JSConstructor(window.createGearTooth)
 
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="plotarea" 的 canvas 上
cgo = cango("gear1")
 
######################################
# 畫正齒輪輪廓
#####################################
# n 為齒數
n = 17
# pa 為壓力角
pa = 25
# m 為模數, 根據畫布的寬度, 計算適合的模數大小
# Module = mm of pitch diameter per tooth
m = 0.8*canvas.width/n
# pr 為節圓半徑
pr = n*m/2 # gear Pitch radius
# generate gear
data = creategeartooth(m, n, pa)
# Brython 程式中的 print 會將資料印在 Browser 的 console 區
#print(data)
gearTooth = cobj(data, "SHAPE", {
        "fillColor":"#ddd0dd",
        "border": True,
        "strokeColor": "#606060" })
gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
# 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
gear = gearTooth.dup()
# gear 為單一齒的輪廓資料
#cgo.render(gearTooth)
 
# 利用單齒輪廓旋轉, 產生整個正齒輪外形
for i in range(1, n):
    # 將 gearTooth 中的資料複製到 newTooth
    newTooth = gearTooth.dup()
    # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
    newTooth.rotate(360*i/n)
    # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號
    gear.appendPath(newTooth, True) # trim move command = True
 
# 建立軸孔
# add axle hole, hr 為 hole radius
hr = 0.6*pr # diameter of gear shaft
shaft = cobj(shapedefs.circle(hr), "PATH")
shaft.revWinding()
gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
cx = canvas.width/2
cy = canvas.height/2
gear.translate(cx, cy)
# render 繪出靜態正齒輪輪廓
cgo.render(gear)
&lt;/script&gt;</t>
<t tx="leo.20170509173005.4">#https://github.com/utlco/tcnc/blob/master/tcnc/geom/fillet.py
#-----------------------------------------------------------------------------
# Copyright 2012-2016 Claude Zervas
# email: claude@utlco.com
#-----------------------------------------------------------------------------
"""
Connect Line/Arc segments with a fillet arc.
"""
# Python 3 compatibility boilerplate
from __future__ import (absolute_import, division,
                        print_function, unicode_literals)
from future_builtins import *

import math

# For debugging:
import logging
logger = logging.getLogger(__name__)

from . import debug
from . import const
from .line import Line
from .arc import Arc

def fillet_path(path, radius, fillet_close=True):
    """Attempt to insert a circular arc of the specified radius
    to connect adjacent path segments.

    Args:
        path: A list of Line or Arc segments.
        radius: The radius of the fillet arc.
        fillet_close: If True and the path is closed then
            add a terminating fillet. Default is False.

    Returns:
        A new path with fillet arcs. If no fillets are created then
        the original path will be returned.
    """
    if radius &lt; const.EPSILON or len(path) &lt; 2:
        return path
    new_path = []
    seg1 = path[0]
    for seg2 in path[1:]:
        new_segs = insert_fillet(seg1, seg2, radius)
        if new_segs:
            new_path.extend(new_segs[:-1])
            seg2 = new_segs[-1]
        else:
            new_path.append(seg1)
        seg1 = seg2
    new_path.append(seg1)
    # Close the path with a fillet
    if fillet_close and len(path) &gt; 2 and path[0].p1 == path[-1].p2:
        new_segs = insert_fillet(new_path[-1], new_path[0], radius)
        if new_segs:
            new_path[-1] = new_segs[0]
            new_path.append(new_segs[1])
            new_path[0] = new_segs[2]
    # Discard the path copy if no fillets were created...
    return new_path if len(new_path) &gt; len(path) else path


def fillet_polygon(poly, radius, fillet_close=True):
    """Attempt to insert a circular arc of the specified radius
    connecting adjacent polygon segments.

    Args:
        poly: A list of polygon vertices.
        radius: The radius of the fillet arc.
        fillet_close: If True and the path is closed then
            add a terminating fillet. Default is True.

    Returns:
        A new path with fillet arcs as a list of Line and Arc segments.
        If no fillets are created then the original path will be returned.
    """
    if len(poly) &lt; 2:
        return ()
    seg1 = Line(poly[0], poly[1])
    if len(poly) == 2:
        return (seg1,)
    path = []
    for p in poly[2:]:
        seg2 = Line(seg1.p2, p)
        new_segs = insert_fillet(seg1, seg2, radius)
        if new_segs:
            path.append(new_segs[0])
            path.append(new_segs[1])
            seg1 = new_segs[2]
        else:
            path.append(seg1)
            seg1 = seg2
    path.append(seg1)
    if fillet_close and len(path) &gt; 2 and path[0].p1 == path[-1].p2:
        new_segs = insert_fillet(path[-1], path[0], radius)
        if new_segs:
            path[-1] = new_segs[0]
            path.append(new_segs[1])
            path[0] = new_segs[2]
    return path


def insert_fillet(seg1, seg2, radius):
    """Try to create a fillet between two segments.
    Any GCode rendering hints attached to the segments will
    be preserved.

    Args:
        seg1: First segment, an Arc or a Line.
        seg2: Second segment, an Arc or a Line.
        radius: Fillet radius.

    Returns:
        A tuple containing the adjusted segments and fillet arc:
        (seg1, fillet_arc, seg2)
        Returns an empty tuple if the segments cannot be connected
        with a fillet arc (either they are too small
        or somehow degenerate.)
    """
    farc = create_fillet_arc(seg1, seg2, radius)
    if farc is None:
        return ()
    return connect_fillet(seg1, farc, seg2)


def connect_fillet(seg1, farc, seg2):
    """Connect two segments with a fillet arc.
    This will adjust the lengths of the segments to
    accommodate the fillet."""
    if isinstance(seg1, Line):
        new_seg1 = Line(seg1.p1, farc.p1)
        if isinstance(seg2, Line):
            # Connect Line-&gt;Fillet-&gt;Line
            new_seg2 = Line(farc.p2, seg2.p2)
        else:
            # Connect Line-&gt;Fillet-&gt;Arc
            new_angle = seg2.angle - seg2.center.angle2(seg2.p1, farc.p2)
            new_seg2 = Arc(farc.p2, seg2.p2, seg2.radius, new_angle,
                                seg2.center)
    else:
        new_angle = seg1.angle - seg1.center.angle2(farc.p1, seg1.p2)
        new_seg1 = Arc(seg1.p1, farc.p1, seg1.radius, new_angle,
                            seg1.center)
        if isinstance(seg2, Line):
            # Connect Arc-&gt;Fillet-&gt;Line
            new_seg2 = Line(farc.p2, seg2.p2)
        else:
            # Connect Arc-&gt;Fillet-&gt;Arc
            new_angle = seg2.angle - seg2.center.angle2(seg2.p1, farc.p2)
            new_seg2 = Arc(farc.p2, seg2.p2, seg2.radius, new_angle,
                                seg2.center)
    return (new_seg1, farc, new_seg2)


def create_fillet_arc(seg1, seg2, radius):
    """Try to create a fillet between two segments.

    Args:
        seg1: First segment, an Arc or a Line.
        seg2: Second segment, an Arc or a Line.
        radius: Fillet radius.

    Returns:
        A fillet arc or None if the segments cannot be connected
        with a fillet arc (either they are too small, already G1
        continuous, or are somehow degenerate.)
    """
    farc = None
    if isinstance(seg1, Line):
        if isinstance(seg2, Line):
            farc = fillet_line_line(seg1, seg2, radius)
        elif isinstance(seg2, Arc):
            farc = fillet_line_arc(seg1, seg2, radius)
    elif isinstance(seg1, Arc):
        if isinstance(seg2, Line):
            farc = fillet_line_arc(seg2, seg1, radius)
        elif isinstance(seg2, Arc):
            farc = fillet_arc_arc(seg1, seg2, radius)
    return farc


def fillet_line_line(line1, line2, fillet_radius):
    """Create a fillet arc between two line segments.

    Args:
        line1: A Line.
        line2: A Line connected to line1.
        fillet_radius: The radius of the fillet.

    Returns:
        An Arc, or None if the fillet radius is too big to fit or
        if the two segments are not connected.
    """
    fillet_arc = None # default return value
    lineside = line1.which_side(line2.p2)
    offset = fillet_radius * lineside
    offset_line1 = line1.offset(offset)
    offset_line2 = line2.offset(offset)
    fillet_center = offset_line1.intersection(offset_line2)
    if fillet_center is not None:
        fp1 = line1.normal_projection_point(fillet_center, segment=True)
        fp2 = line2.normal_projection_point(fillet_center, segment=True)
        # Test for fillet fit
        if (fp1 is not None and fp2 is not None and fp1 != fp2
                and const.float_eq(fp1.distance(fillet_center), fillet_radius)
                and const.float_eq(fp2.distance(fillet_center), fillet_radius)):
            fillet_arc = Arc.from_two_points_and_center(fp1, fp2,
                                                       fillet_center)
    return fillet_arc


def fillet_arc_arc(arc1, arc2, fillet_radius):
    """Create a fillet arc between two connected arcs.

    Args:
        arc1: First arc.
        arc2: Second arc.
        fillet_radius: The radius of the fillet.

    Returns:
        An Arc,
        or None if the fillet radius is too big to fit or
        if the two segments are not connected.
    """
    fillet_arc = None # default return value
    arc2_side = arc1.which_side_angle(arc2.start_tangent_angle())
    cw1 = 1 if arc1.is_clockwise() else -1
    cw2 = 1 if arc2.is_clockwise() else -1
    offset_arc1 = arc1.offset(fillet_radius * arc2_side * cw1)
    offset_arc2 = arc2.offset(fillet_radius * arc2_side * cw2)
    # The intersection of the two offset arcs is the fillet arc center.
    offset_intersections = offset_arc1.intersect_arc(offset_arc2, on_arc=True)
    if offset_intersections:
        fillet_center = offset_intersections[0]
        # Find points normal from fillet center to arc segments
        fline1 = Line(fillet_center, arc1.center)
        fline2 = Line(fillet_center, arc2.center)
        ix1 = arc1.intersect_line(fline1, on_arc=True)
        ix2 = arc2.intersect_line(fline2, on_arc=True)
        if ix1 and ix2:
            fillet_arc = Arc.from_two_points_and_center(ix1[0], ix2[0],
                                                        fillet_center)
    return fillet_arc


def fillet_line_arc(line, arc, fillet_radius):
    """Create a fillet arc between a line segment and a connected arc.
    The fillet arc end point order will match the line-arc order.

    Args:
        line: A Line.
        arc: An Arc.
        fillet_radius: The radius of the fillet.

    Returns:
        An Arc,
        or None if the fillet radius is too big to fit or
        if the two segments are not connected.
    """
    debug.draw_arc(arc, verbose=True)
    # TODO: Maybe replace this novel approach with the more usual
    # offset intersection method..
    fillet_arc = None # default return value

    # If the direction is arc-&gt;line then reverse both
    # to make things simpler.
    is_reversed = False
    if const.float_eq(arc.p2, line.p1):
        # The two segments are connected but in reverse order.
        line = line.reversed()
        arc = arc.reversed()
        is_reversed = True

    arc_side = line.which_side_angle(arc.start_tangent_angle())
    if ((arc_side &gt; 0 and arc.is_clockwise()) or
        (arc_side &lt; 0 and not arc.is_clockwise())):
        h = arc.radius + fillet_radius
        alpha1 = line.angle() + math.pi
    else:
        h = arc.radius - fillet_radius
        alpha1 = line.angle()
    line3 = line.offset(fillet_radius * arc_side)
    p5 = line3.normal_projection_point(arc.center)
    b = p5.distance(arc.center)
    a2 = h*h - b*b
    if a2 &lt; 0:
        return
    a = math.sqrt(a2)
    line4 = Line.from_polar(p5, a, alpha1)
    fillet_center = line4.p2
    alpha2 = abs(arc.center.angle2(arc.p1, fillet_center))
    fp1 = line.normal_projection_point(fillet_center, segment=True)
    fp2 = arc.point_at_angle(alpha2, segment=True)
    if (fp1 is not None and fp2 is not None and fp1 != fp2 and
        const.float_eq(fillet_center.distance(fp1),
                      fillet_center.distance(fp2))):
        if is_reversed:
            fillet_arc = Arc.from_two_points_and_center(fp2, fp1,
                                                             fillet_center)
        else:
            fillet_arc = Arc.from_two_points_and_center(fp1, fp2,
                                                             fillet_center)
    return fillet_arc</t>
<t tx="leo.20170509173005.5">  以下程式對應 canvas:
  
&lt;canvas id="cvs0" width="475" height="300"&gt;&lt;/canvas&gt;
  
&lt;script type="text/javascript"&gt;
    function distanceFromCurve(pt, bezNodes)
    {
      /* Calculates distance from point (pt) to the closest point on cubic Bezier curve (bez)
       * Algoritm suggested by Mike Kamermans http://pomax.github.io/bezierinfo/
       * Note: this is designed for well behaved Bezier curves only (no kinks)
       */
      var mu = 0.5,
          dMu = 1.0,
          dMuMin = 0.000001,
          testPt, testLft, testRgt;

      function pointOnBezier(p)
      {
        var x1 = bezNodes[0].x,
            y1 = bezNodes[0].y,
            x2 = bezNodes[1].x,
            y2 = bezNodes[1].y,
            x3 = bezNodes[2].x,
            y3 = bezNodes[2].y,
            x4 = bezNodes[3].x,
            y4 = bezNodes[3].y,
            f1 = function(t) { return (t*t*t); },
            f2 = function(t) { return (3*t*t*(1-t)); },
            f3 = function(t) { return (3*t*(1-t)*(1-t)); },
            f4 = function(t) { return ((1-t)*(1-t)*(1-t)); },
            /* p from 0 to 1 */
            bezX = function() { return x1*f1(p) + x2*f2(p) + x3*f3(p) + x4*f4(p); },
            bezY = function() { return y1*f1(p) + y2*f2(p) + y3*f3(p) + y4*f4(p); };

        return {x:bezX(), y:bezY()}
      }

      function calcDist(p, u)
      {
        var bezPt = pointOnBezier(u),
            distVal = Math.sqrt((bezPt.x-p.x)*(bezPt.x-p.x)+(bezPt.y-p.y)*(bezPt.y-p.y));

        return {distance: distVal, x: bezPt.x, y: bezPt.y};
      }

      do
      {
        testPt = calcDist(pt, mu);
        // half distance to left
        dMu /= 2;
        testLft = calcDist(pt, mu-dMu);
        testRgt = calcDist(pt, mu+dMu);
        if (testLft.distance&lt;testPt.distance)
        {
          mu -= dMu;
          if (mu&lt;0) { mu = 0; }
        }
        if (testRgt.distance&lt;testPt.distance)
        {
          mu += dMu;
          if (mu&gt;1) { mu = 1; }
        }
      }
      while (dMu&gt;dMuMin)

      return testPt;   // object {distance:, x:, y: }
    }

    function updateErrors(tbl, rowNum, str0, str1, str2)
    {
      var rowId = "t"+tbl+"row"+rowNum;
      var rowNode = document.getElementById(rowId);
      var tds = rowNode.getElementsByTagName("TD");   // array of TD elements
      tds[0].childNodes[0].nodeValue = str0;    // text node of TD element
      tds[1].childNodes[0].nodeValue = str1;
      tds[2].childNodes[0].nodeValue = str2;
    }

    function InvoluteDefined(cvsID, module, teeth, pressureAngle)
    {
      'use strict';
      var savThis = this,
          m, Z, phi, Rpitch, Rb, addendum, Ra,
          toothData, toothObj,
          pitchToBaseAngle,
          gear, invData,
          invMax, invMin,
          xspan, yspan,
          pt, A,
          cx1, cy1,
          c1,
          g, xmin, xmax, ymin, ymax,
          i, theta, newTooth;

      function toCartesian(radius, angle)
      {
        return {x: radius*Math.cos(angle), y: radius*Math.sin(angle)};
      }

      function genInvolute2(Rb, theta)
      {
        // given the parameter theta, return the x, y of the involute
        var ix = Rb*(Math.cos(theta) + theta*Math.sin(theta));
        var iy = Rb*(Math.sin(theta) - theta*Math.cos(theta));

        return {x:ix, y:iy};
      }

      function dragC1(mousePos)    // called in scope of dragNdrop obj
      {
        var xp, yp,
            wPos = {x:mousePos.x - this.grabOfs.x, y:mousePos.y - this.grabOfs.y};
// generate a value of A (involute generating angle) near to the drag point
// origin is at invMin and invMax is the end, get current pos as proportion of inv span
        xp = (wPos.x&lt;0)? 0: wPos.x/xspan;
        if (xp&gt;1)
        {
          xp = 1;
        }
        yp = (wPos.y&lt;0)? 0: wPos.y/yspan;
        if (yp&gt;1)
        {
          yp = 1;
        }
        A = Math.sqrt(0.707*Math.sqrt(xp*xp + yp*yp));
        pt = genInvolute2(Rb, A);
        cx1 = pt.x - Rb;
        cy1 = pt.y;
        savThis.drawInv();
      }

      g = new Cango(cvsID);      // g is the graphics context for the background
      xmin = -54;
      xmax = 20;
      ymin = -5;
      ymax = 40;

      g.setGridboxRHC();          // full canvas
      g.setWorldCoords(xmin, ymin, xmax-xmin);   // square pixels
      g.setPropertyDefault("fillColor", 'black');
      g.setPropertyDefault("fontSize", 12);
      // =============== DIN GEAR DESIGN ===================
      m = module;                // Module = teeth per inch of diamter
      Z = teeth;
      phi = pressureAngle || 20; // pressure angle in degs
      Rpitch = Z*m/2;                // pitch radius
      Rb = Rpitch*Math.cos(phi*Math.PI/180);  // base radius
      addendum = m;             // distance from pitch circle to outer circle
      Ra = Rpitch + addendum;       // addendum (outer) radius
      // generate gear tooth outline path
      toothData = createGearTooth(m, Z, phi);
      toothObj = new Path(toothData, {strokeColor:'red'});
      toothObj.rotate(-270/Z);
      // rotate the tooth to put start of involute on the x axis
      pitchToBaseAngle = (Math.sqrt(Rpitch*Rpitch - Rb*Rb)/Rb) - Math.acos(Rb/Rpitch);
      toothObj.rotate(180*pitchToBaseAngle/Math.PI);
      // make 5 teeth by duplicating
      gear = [];
      gear.push(toothObj);
      for (i=0, newTooth; i&lt;4; i++)
      {
        newTooth = toothObj.dup();
        newTooth.rotate(360*i/Z);
        gear.push(newTooth);
      }
      // now draw the extended involute
      invData = [];
      pt = {};
      for (theta=0; theta&lt;1; theta+= 0.05)   // step along involute by inc parameter
      {
        pt = genInvolute2(Rb, theta);
        invData.push(pt.x, pt.y);
      }
      invMax = genInvolute2(Rb, 1);
      invData.push(invMax.x, invMax.y);   // plot the last point (theta = 1 radian)
      invMin = {x:Rb, y: 0} ;
      xspan = invMax.x-invMin.x;      // use these when dragging dot
      yspan = invMax.y-invMin.y;
      A = 0.8;                    // initial involute generating angle 0.8 rads
      cx1 = 59.7-Rb;
      cy1 = 7.5;  // eqiv x,y on involute for 0.8 theta
      // compile the involute control point and make it draggable
      c1 = new Shape(shapeDefs.circle(2), {fillColor:'red', iso:true});
      c1.enableDrag(null, dragC1, null);

      this.showConst = false;    // show construction lines

      this.drawInv = function()
      {
        var compA, gPt, genLines;

        g.clearCanvas();
        g.drawAxes(xmin, xmax, ymin, ymax, {xOrigin:-Rb, yOrigin:0, yTickInterval:50, strokeColor:"#888888", fillColor:"#888888"});  // don't show y ticks
        g.render(gear, {x:-Rb, y:0});
        g.drawPath(shapeDefs.circle(Rb*2), {x:-Rb, y:0, strokeColor:'rgba(0,0,255,0.3)'});

        g.drawPath(invData, {x:-Rb, y:0, strokeColor:'magenta'});

        // draw generating right angle
        compA = Math.PI/2 - A;
        gPt = toCartesian(Rb, A);
        genLines = ['M', 0, 0, 'l', gPt.x, gPt.y, Rb*A*Math.cos(compA), -Rb*A*Math.sin(compA)];
        g.drawPath(genLines, {x:-Rb, y:0});
        // draw little right angle sign
        genLines = ['M', 0.95*gPt.x, 0.95*gPt.y, 'l', 0.05*Rb*Math.cos(compA), -0.05*Rb*Math.sin(compA),
                    0.05*Rb*Math.cos(A), 0.05*Rb*Math.sin(A)];
        g.drawPath(genLines, {x:-Rb, y:0});
        // draw draggable end point
        g.render(c1, {x:cx1, y:cy1});
        if (this.showConst)
        {
          genLines = ['M', 0, 0, 'L', gPt.x, gPt.y, gPt.x, 0, "Z", "M", gPt.x, gPt.y,
                      "l", Rb*A*Math.cos(compA), -Rb*A*Math.sin(compA), -Rb*A*Math.cos(compA), 0, "Z"];
          g.drawPath(genLines, {x:-Rb, y:0});
          // label if they fit
          g.drawText("R", {x:gPt.x/2-Rb-1.8, y:gPt.y/2+1.5, lorg:9});
          g.drawText("b", {x:gPt.x/2-Rb-1, y:gPt.y/2+1, fontSize:10, lorg:9});
          if (A&gt;0.3)
          {
            g.drawArrowArc(7.5, 0, 180*A/Math.PI, {
              x:-Rb, y:0,
              fillColor:"#aaaaaa",
              clockWise:false,
              shaftWidth:1,
              headSize:7});
            g.drawText("\u03B8", {x:gPt.x/4-Rb, y:gPt.y/8, lorg:4});
            g.drawText("x'", {x:2*gPt.x/3-Rb, y:2, lorg:5});
            g.drawText("y'", {x:gPt.x-Rb-1, y:gPt.y/3, lorg:3});
            g.drawText("\u03B8", {x:gPt.x-Rb+Rb*A*Math.sin(A)/20, y:gPt.y-4, lorg:1});
            g.drawText("x", {x:gPt.x-Rb+Rb*A*Math.sin(A)/2, y:gPt.y-Rb*A*Math.cos(A)+1, lorg:9});
            g.drawText("y", {x:gPt.x-Rb+1, y:2*gPt.y/3, lorg:1});
            g.drawText("c", {x:gPt.x-Rb+Rb*A*Math.sin(A)/2+1, y:gPt.y-Rb*A*Math.cos(A)/2+1, lorg:7});
            g.drawText("c'", {x:-Rb+Rb*Math.cos(A/2)-1, y:Rb*Math.sin(A/2)-1, lorg:6});
          }
        }
      };

      this.drawInv();
    }

    function InvoluteDefined2(cvsID, module, teeth, pressureAngle)
    {
      'use strict';
      var m, Z, phi,
          Rpitch, Rb, addendum, Ra,
          toothData, toothObj,
          pitchToBaseAngle,
          gear, i, newTooth,
          invData, pt, theta,
          invMax, invMin,
          xspan, yspan,
          A, cx1, cy1,
          compA, gPt,
          genLines, ph,
          g, xmin, xmax, ymin, ymax;

      function toCartesian(radius, angle)
      {
        return {x: radius*Math.cos(angle), y: radius*Math.sin(angle)};
      }

      function genInvolute2(Rb, theta)
      {
        // given the parameter theta, return the x, y of the involute
        var ix = Rb*(Math.cos(theta) + theta*Math.sin(theta)),
            iy = Rb*(Math.sin(theta) - theta*Math.cos(theta));

        return {x:ix, y:iy};
      }

      xmin = -45;
      xmax = 20;
      ymin = -4;
      ymax = 40;
      g = new Cango(cvsID);     // g is the graphics context for the background
      g.setGridboxRHC();          // full canvas
      g.setWorldCoords(xmin, ymin, xmax-xmin);  // square pixels
      g.setPropertyDefault("fillColor", 'black');
      g.setPropertyDefault("fontSize", 12);
      // =============== DIN GEAR DESIGN ===================
      m = module;                // Module = teeth per inch of diamter
      Z = teeth;
      phi = pressureAngle || 20; // pressure angle in degs
      Rpitch = Z*m/2;                // pitch radius
      Rb = Rpitch*Math.cos(phi*Math.PI/180);  // base radius
      addendum = m;             // distance from pitch circle to outer circle
      Ra = Rpitch + addendum;       // addendum (outer) radius
      // generate gear tooth outline path
      toothData = createGearTooth(m, Z, phi);
      toothObj = new Path(toothData, {strokeColor:'red'});
      toothObj.rotate(-270/Z);
      // rotate the tooth to put start of involute on the x axis
      pitchToBaseAngle = (Math.sqrt(Rpitch*Rpitch - Rb*Rb)/Rb) - Math.acos(Rb/Rpitch);
      toothObj.rotate(180*pitchToBaseAngle/Math.PI);
      // make 5 teeth by duplicating
      gear = [];
      gear.push(toothObj);
      for (i=0, newTooth; i&lt;3; i++)
      {
        newTooth = toothObj.dup();
        newTooth.rotate(360*i/Z);
        gear.push(newTooth);
      }
      // now draw the extended involute
      invData = [];
      pt = {};
      for (theta=0; theta&lt;1; theta+= 0.05)   // step along involute by inc parameter
      {
        pt = genInvolute2(Rb, theta);
        invData.push(pt.x, pt.y);
      }
      invMax = genInvolute2(Rb, 1);
      invData.push(invMax.x, invMax.y);   // plot the last point (theta = 1 radian)
      invMin = {x:Rb, y: 0} ;
      xspan = invMax.x-invMin.x;      // use these when dragging dot
      yspan = invMax.y-invMin.y;
      A = 0.8;                    // initial involute generating angle 0.8 rads
      cx1 = 59.7-Rb;
      cy1 = 7.5;  // eqiv x,y on involute for 0.8 theta

      g.clearCanvas();
      g.drawAxes(xmin, xmax, ymin, ymax, {
        xOrigin:-Rb, yOrigin:0,
        yTickInterval:50,
        strokeColor:"#888888",
        fillColor:"#888888"});  // don't show y ticks
      g.render(gear, {x:-Rb, y:0});
      g.drawPath(shapeDefs.circle(Rb*2), {x:-Rb, y:0, strokeColor:'rgba(0,0,255,0.3)'});
      g.drawPath(invData, {x:-Rb, y:0, strokeColor:'magenta'});
      // draw generating right angle
      compA = Math.PI/2 - A;
      gPt = toCartesian(Rb, A);
      genLines = ['M', 0, 0, 'l', gPt.x, gPt.y, Rb*A*Math.cos(compA), -Rb*A*Math.sin(compA), 'z'];
      g.drawPath(genLines, {x:-Rb, y:0});

      g.drawArrowArc(9, 0, 180*A/Math.PI, {
        x:-Rb, y:0,
        fillColor:"#aaaaaa",
        clockwise:false,
        shaftWidth:1,
        headSize:7});
      ph = 0.13;
      g.drawArrowArc(20, 0, 180*ph/Math.PI, {
        x:-Rb, y:0,
        fillColor:"#aaaaaa",
        clockWise:false,
        shaftWidth:1,  
        headSize:7});
      // draw little right angle sign
      genLines = ['M', 0.95*gPt.x, 0.95*gPt.y, 'l', 0.05*Rb*Math.cos(compA), -0.05*Rb*Math.sin(compA),
                  0.05*Rb*Math.cos(A), 0.05*Rb*Math.sin(A)];
      g.drawPath(genLines, {x:-Rb, y:0});
      // label if they fit
      g.drawText("R", {x:gPt.x/2-Rb-1.8, y:gPt.y/2+1.5, lorg:9});
      g.drawText("b", {x:gPt.x/2-Rb-1, y:gPt.y/2+1, fontSize:10, lorg:9});
      g.drawText("R", {x:gPt.x-Rb, y:gPt.y/6, lorg:9});
      g.drawText("\u03B8", {x:3*gPt.x/8-Rb, y:gPt.y/8, lorg:4});
      g.drawText("\u03C8", {x:7*gPt.x/8-Rb, y:1.5, lorg:5});
      g.drawText("c", {x:gPt.x-Rb+Rb*A*Math.sin(A)/2+1, y:gPt.y-Rb*A*Math.cos(A)/2+1, lorg:7});
      g.drawText("c'", {x:-Rb+Rb*Math.cos(A/2)-1, y:Rb*Math.sin(A/2)-1, lorg:6});
    }

    function InvoluteProfile(g, module, teeth, pressureAngle)
    {
      'use strict';
      var m, Z, phi, Rpitch, Rb, addendum, Ra, ta, order,
          fs, fm, fe,
          dedBez, addBez, bez,
          xmin, xmax, ymin, ymax;

      function genInvolute2(Rb, theta)
      {
        // given the parameter theta, return the x, y of the involute
        var ix = Rb*(Math.cos(theta) + theta*Math.sin(theta)),
            iy = Rb*(Math.sin(theta) - theta*Math.cos(theta));

        return {x:ix, y:iy};
      }

      xmin = -3;
      xmax = 3;
      ymin = -0.5;
      ymax = 5.5;

      g.setGridboxRHC();
      g.setWorldCoords(xmin, ymin, xmax-xmin);  // square pixels

      // =============== Demo Gear ===================
      m = module;                         // Module = pitch diameter (mm)/teeth
      Z = teeth;
      phi = pressureAngle || 20;          // pressure angle in degs
      Rpitch = Z*m/2;                     // pitch radius
      Rb = Rpitch*Math.cos(phi*Math.PI/180);  // base radius
      addendum = m;                       // pitch circle to outer circle
      Ra = Rpitch + addendum;             // addendum (outer) radius
      ta = Math.sqrt(Ra*Ra-Rb*Rb)/Rb;     // involute angle at addendum
      order = 4;

      this.drawCubicBezInvolute = function()
      {
        var data, p, theta, row, sa, s, err, pt;

        // generate 2 Cubic Bezier approximation
        fs = 0.01;  // start 1% off the base circle
        fm = 0.25;  // break 25% along involute
        fe = 1;     // end at 100%
        dedBez = involuteBezCoeffs(m, Z, phi, 3, fs, fm);
        addBez = involuteBezCoeffs(m, Z, phi, 3, fm, fe);

        g.clearCanvas();
        g.drawAxes(-5, 5, -5, 5, {
          xOrigin:0,
          yOrigin:0,
          xUnits:"mm",
          yUnits:"mm",
          xLabel:"X",
          yLabels:"Y" });
        g.drawPath(shapeDefs.circle(Rpitch*2), {x:-Rpitch, y:0, strokeColor:'orange'});
        g.drawPath(shapeDefs.circle(Rb*2), {x:-Rpitch, y:0, strokeColor:'red'});
        g.drawPath(shapeDefs.circle(Ra*2), {x:-Rpitch, y:0, strokeColor:'green'});

        // draw the approximation
        data = ["M", dedBez[0].x, dedBez[0].y,
                    "C", dedBez[1].x, dedBez[1].y, dedBez[2].x, dedBez[2].y, dedBez[3].x, dedBez[3].y,
                    "C", addBez[1].x, addBez[1].y, addBez[2].x, addBez[2].y, addBez[3].x, addBez[3].y];
        g.drawPath(data, {x:-Rpitch, y:0, strokeColor:'blue'});
        // plot the Bezier nodes as exes
        for (p=0; p&lt;dedBez.length; p++)    // skip duplicate at start
        {
          g.drawPath(shapeDefs.ex(0.2), {x:dedBez[p].x-Rpitch, y:dedBez[p].y, strokeColor:'blue'});
        }
        // plot the Bezier nodes
        for (p=0; p&lt;addBez.length; p++)    // skip duplicate at start
        {
          g.drawPath(shapeDefs.cross(0.2), {x:addBez[p].x-Rpitch, y:addBez[p].y, strokeColor:'green'});
        }
        // calculate the errors
        sa = (Ra*Ra - Rb*Rb)/(2*Rb);
        for (theta=0.08, row=0; theta&lt;ta; theta+= 0.08, row++)   // step along involute
        {
          pt = genInvolute2(Rb, theta);
          // calculate the errors
          s = Rb*theta*theta/2;
          if ((s/sa) &lt; 0.25)
          {
            err = distanceFromCurve(pt, dedBez);
          }
          else
          {
            err = distanceFromCurve(pt, addBez);
          }
          // write the error in table
          updateErrors(2, row, sprintf("%4.2f", s/sa), sprintf("%7.5f", err.distance), sprintf("%.1E", err.distance/(Z*m)));
        }
      };

      this.drawRealInvolute = function()
      {
        var theta, pt,
          data = [];

        // now draw the real involute
        for (theta=0; theta&lt;ta; theta+= 0.01)   // step along involute
        {
          pt = genInvolute2(Rb, theta);
          data.push(pt.x, pt.y);
        }
        pt = genInvolute2(Rb, ta);     // add the end point
        data.push(pt.x, pt.y);
        g.drawPath(data, {x:-Rpitch, y:0, strokeColor:'magenta'});
      };

      this.drawCubicBezInvolute();
      this.drawRealInvolute();
    }

    function InvoluteOrderN(g, module, teeth, pressureAngle, bezOrder)
    {
      'use strict';
      var m, Z, phi, Rpitch, Rb, addendum, Ra, order,
          fs, fe,
          ta, ts,
          bez,
          xmin, xmax, ymin, ymax;

      function genInvolute2(Rb, theta)
      {
        // given the parameter theta, return the x, y of the involute
        var ix = Rb*(Math.cos(theta) + theta*Math.sin(theta)),
            iy = Rb*(Math.sin(theta) - theta*Math.cos(theta));

        return {x:ix, y:iy};
      }

     /* Computes deCasteljau p(t) for n-control points
      * @param cp - list of control points [][x,y]
      * @param r - amount points (init value : points.length-1)
      * @param i - start value (init value : 0)
      * @param t - portion on the graph (range between 0.0 and 1.0)
      * @return point{x:,y:} - point on graph at p(t)
      *
      * @see http://stackoverflow.com/a/6271870 for n-control points
      */
      function getBezierPoint(cp, r, i, t)
      {
        var p1, p2;

        if (r == 0)
        {
          return cp[i];
        }
        p1 = getBezierPoint(cp, r - 1, i, t);
        p2 = getBezierPoint(cp, r - 1, i + 1, t);

        return {x:(1 - t) * p1.x + t * p2.x, y:(1 - t) * p1.y + t * p2.y};
      }

      xmin = -3;
      xmax = 3;
      ymin = -0.5;
      ymax = 5.5;

      g.setGridboxRHC();          // full canvas
      g.setWorldCoords(xmin, ymin, xmax-xmin);  // square pixels

      // =============== this Demo Gear has Rroot &lt; Rbase ===================
      m = module;                         // Module = pitch diameter (mm)/teeth
      Z = teeth;
      phi = pressureAngle || 20;          // pressure angle in degs
      Rpitch = Z*m/2;                     // pitch radius
      Rb = Rpitch*Math.cos(phi*Math.PI/180);  // base radius
      addendum = m;                       // pitch circle to outer circle
      Ra = Rpitch + addendum;             // addendum (outer) radius
      order = bezOrder || 4;
      fs = 0.01;                          // start offset as fraction of length
      fe = 1;                             // fraction of length at end of approx
      ta = Math.sqrt(Ra*Ra-Rb*Rb)/Rb;     // involute angle at addendum, end of approx
      ts = Math.sqrt(fs)*ta;              // involute angle, theta, at start of approx
      // generate Bezier approximation
      bez = involuteBezCoeffs(m, Z, phi, order, fs, fe);

      this.drawBezInvolute = function()
      {
        var data = [],
            t, p, pt, theta, row,
            sa, s, err;

        g.clearCanvas();
        g.drawAxes(-5, 5, -5, 5, {
          xOrigin:0,
          yOrigin:0,
          xUnits:"mm",
          yUnits:"mm",
          xLabel:"X",
          yLabels:"Y"});
        g.drawPath(shapeDefs.circle(Rpitch*2), {x:-Rpitch, y:0, strokeColor:'orange'});
        g.drawPath(shapeDefs.circle(Rb*2), {x:-Rpitch, y:0, strokeColor:'red'});
        g.drawPath(shapeDefs.circle(Ra*2), {x:-Rpitch, y:0, strokeColor:'green'});

        // draw approximation Bezier
        for (theta=ts; theta&lt;ta; theta+= 0.05) // fraction of theta_a
        {
          t =  (theta-ts)/(ta - ts);  // map t (0 &lt;= t &lt;= 1) from theta (ts &lt;= theta &lt;= ta)
          pt = getBezierPoint(bez, order, 0, t);
          data.push(pt.x, pt.y);
        }
        // add the end point
        data.push(bez[bez.length-1].x, bez[bez.length-1].y);
        g.drawPath(data, {x:-Rpitch, y:0, strokeColor:'green'});
        // plot the Bezier nodes
        for (p=0; p&lt;bez.length; p++)
        {
          g.drawPath(shapeDefs.ex(0.2), {x:bez[p].x-Rpitch, y:bez[p].y, strokeColor:'green'});
        }

        // calculate the errors (need a higher order version of Simon Porritt's jsBezier code)
        if (order==3)
        {
          sa = (Ra*Ra - Rb*Rb)/(2*Rb);
          for (theta=0.08, row=0; theta&lt;ta; theta+= 0.08, row++)   // step along involute
          {
            pt = genInvolute2(Rb, theta);
            // calculate the errors
            s = Rb*theta*theta/2;
            err = distanceFromCurve(pt, bez);
            // write the error in table
            updateErrors(1, row, sprintf("%4.2f", s/sa),
                                 sprintf("%6.4f", err.distance),
                                 sprintf("%.1E", err.distance/(Z*m)));
          }
        }
      };

      this.drawRealInvolute = function()
      {
        var theta, pt,
            data = [];

        // now draw the real involute
        for (theta=0; theta&lt;ta; theta+= 0.01)   // step along involute by inc parameter
        {
          pt = genInvolute2(Rb, theta);
          data.push(pt.x, pt.y);
        }
        pt = genInvolute2(Rb, ta);     // add the end point
        data.push(pt.x, pt.y);
        g.drawPath(data, {x:-Rpitch, y:0, strokeColor:'magenta'});
      };

      this.drawBezInvolute();
      this.drawRealInvolute();
    }

    function initGear(opts)
    {
      // create the required contents of next state vector (the default for others are OK)
      this.nextState.x = opts.cx;
      this.nextState.y = opts.cy;
    }

    function GearAnimation(g, module, gearTeeth, pinionTeeth, pressureAngle)
    {
      'use strict';
      // =============== DIN GEAR DESIGN ===================
      var m = module,               // Module = mm of pitch diameter per tooth
          Zp = pinionTeeth,
          Zg = gearTeeth,
          gr = Zg/Zp,               // gear ratio
          phi = pressureAngle || 20,
          Rg = Zg*m/2,              // gear Pitch Radius
          Rp = Zp*m/2,              // pinion Pitch Radius
          bklsh = 0.04*m,           // backlash (mm)
          dC = bklsh/(2*Math.tan(Math.PI*phi/180)), // centre shift to make backlash
          data, newTooth,
          Dsg, gearTooth, gear,
          Dsp, pinionTooth, pinion,
          shaft,
          org, cx, cy,
          xmin = -50,
          ymin = -30,
          xspan = 100,
          i,
          gearConfig, pinionConfig,
          twnr;

      g.setGridboxRHC();
      g.setWorldCoords(xmin, ymin, xspan);

      // generate gear
      data = createGearTooth(m, Zg, phi);
      gearTooth = new Shape(data, {
        fillColor:"#ddd0dd",
        border: true,
        strokeColor: "#606060" });
      gearTooth.rotate(180/Zg);     // rotate gear 1/2 tooth to mesh
      gear = gearTooth.dup();
      for (i=1; i&lt;Zg; i++)
      {
        newTooth = gearTooth.dup();
        newTooth.rotate(360*i/Zg);
        gear.appendPath(newTooth, true);  // trim move command = true
      }
      // add axle hole
      Dsg = 0.6*Rg;             // diameter of gear shaft
      shaft = new Path(shapeDefs.circle(Dsg));
      shaft.revWinding();
      gear.appendPath(shaft);       // retain the 'moveTo' command for shaft sub path

      // generate pinion
      data = createGearTooth(m, Zp, phi);
      pinionTooth = new Shape(data, {
        fillColor:"#d0d0e8",
        border: true,
        strokeColor: "#606060" });
      pinionTooth.rotate(-(180/Math.PI)*0.5*bklsh/Rp);  // rotate gear to take up backlash
      pinion = pinionTooth.dup();
      for (i=1; i&lt;Zp; i++)
      {
        newTooth = pinionTooth.dup();
        newTooth.rotate(360*i/Zp);
        pinion.appendPath(newTooth, true);  // trim 'moveto' command = true
      }
      // add axle hole
      Dsp = 0.6*Rp;             // diameter of pinion shaft
      shaft = new Path(shapeDefs.circle(Dsp));
      shaft.revWinding();
      pinion.appendPath(shaft);     // retain the 'moveTo' command for shaft sub path

      // setup the animation
      gearConfig = {cx:-Rg, cy:0, degs:[0, 360]};
      pinionConfig = {cx:Rp+dC, cy:0, degs:[0, -gr*360]};  // gr*0.666 rpm
			twnr = new Tweener(0, 90000, "loop");               // 0.666 rpm

      function initGear(opts)
      {
        // create the required contents of next state vector (the default for others are OK)
        this.nextState.x = opts.cx;
        this.nextState.y = opts.cy;
      }

      function gearPath(time, opts)
      {
        var rotVal = twnr.getVal(time, opts.degs);
        // create the required contents of next state vector (the default for others are OK)
        this.nextState.degs = rotVal;
      }

      g.animate(gear, initGear, null, gearPath, gearConfig);
      g.animate(pinion, initGear, null, gearPath, pinionConfig);

      this.run = function()
      {
        g.playAnimation();
      };

      this.halt = function()
      {
        g.pauseAnimation();
      };

      g.playAnimation();
    }

    function IntGearAnimation(g, module, gearTeeth, pinionTeeth, pressureAngle)
    {
      'use strict';
      // ==================== DIN GEAR DESIGN ====================
      var m = module,           // Module = teeth per inch of diamter
          Zp = pinionTeeth,
          Zg = gearTeeth,
          gr = Zg/Zp,           // gear teeth
          phi = pressureAngle || 20,
          Rg = Zg*m/2,          // gear Pitch radius
          Rp = Zp*m/2,          // pinion Pitch radius
          Rrim = Rg+2.75*m,     // ring gear outer radius
          bklsh = 0.04*m,       // backlash
          dC = bklsh/(2*Math.tan(Math.PI*phi/180)), // centre shift to make backlash
          data, newTooth,
          gear, gearTooth, teeth,
          pinion, pinionTooth,
          Rshaft, shaft,
          org, cx, cy,
          xmin = -250,
          ymin = -125,
          xspan = 400,
          i,
          gearConfig, pinionConfig,
          twnr;

      g.setGridboxRHC();              // full canvas
      g.setWorldCoords(xmin, ymin, xspan);

      // create ring gear outer rim
      gear = new Shape(shapeDefs.circle(2*Rrim), {
        fillColor:"#ddddd0",
        border: true,
        strokeColor: "#606060" });
      gear.revWinding();   // reverse winding so hole center hole won't be filled
      // now generate ring gear teeth
      data = createIntGearTooth(m, Zg, phi);
      gearTooth = new Path(data);
      gearTooth.rotate(180/Zg);  // rotate gear 1/2 tooth to mesh
      teeth = gearTooth.dup();
      for (i=1, newTooth; i&lt;Zg; i++)
      {
        newTooth = gearTooth.dup();
        newTooth.rotate(360*i/Zg);
        teeth.appendPath(newTooth, true); // trim initial 'moveTo'
      }
      gear.appendPath(teeth);   // retain the moveTo to make sub-path
      // generate pinion
      data = createGearTooth(m, Zp, phi);
      pinionTooth = new Shape(data, {
        fillColor:"#d0dddd",
        border: true,
        strokeColor: "#606060" });
      pinionTooth.rotate((180/Math.PI)*0.5*bklsh/Rp);  // rotate gear close backlash
      pinion = pinionTooth.dup();
      for (i=1; i&lt;Zp; i++)
      {
        newTooth = pinionTooth.dup();
        newTooth.rotate(360*i/Zp);
        pinion.appendPath(newTooth, true);  // trim move command = true
      }
      // add axle shaft hole
      Rshaft = 0.3*Rp;      // shaft radius
      shaft = new Path(shapeDefs.circle(2*Rshaft));
      shaft.revWinding();       // reverse the winding so hole not filled
      pinion.appendPath(shaft); // retain the moveTo to make sub-path

      // setup the animation
      gearConfig = {cx:-Rg, cy:0, degs:[0, 360]};
      pinionConfig = {cx:-Rp-dC, cy:0, degs:[0, gr*360]};    // gr*1 rpm
			twnr = new Tweener(0, 60000, "loop");                 // 1 rpm

      function initGear(opts)
      {
        // create the required contents of next state vector (the default for others are OK)
        this.nextState.x = opts.cx;
        this.nextState.y = opts.cy;
      }

      function gearPath(time, opts)
      {
        var rotVal = twnr.getVal(time, opts.degs);
        // create the required contents of next state vector (the default for others are OK)
        this.nextState.degs = rotVal;
      }

      g.animate(gear, initGear, null, gearPath, gearConfig);
      g.animate(pinion, initGear, null, gearPath, pinionConfig);

      this.run = function()
      {
        g.playAnimation();
      };

      this.halt = function()
      {
        g.pauseAnimation();
      };

      g.playAnimation();
    }

//============================================================
    var invDiagram, involuteDemo1, involuteDemo2, gearDemo, intGearDemo;

    function init()
    {
      var g1, g2, g3, g4;

      invDiagram = new InvoluteDefined('cvs0', 5, 20, 20);
      InvoluteDefined2('cvsA', 10, 8, 20);

      g1 = new Cango('cvs1');
      involuteDemo1 = new InvoluteOrderN(g1, 3, 17, 25, 3);
      initZoomPan(g1.createLayer(), g1, function(){involuteDemo1.drawBezInvolute(); involuteDemo1.drawRealInvolute();});

      g2 = new Cango('cvs2');
      involuteDemo2 = new InvoluteProfile(g2, 3, 17, 25);
      initZoomPan(g2.createLayer(), g2, function(){involuteDemo2.drawCubicBezInvolute(); involuteDemo2.drawRealInvolute();});

      g3 = new Cango('cvs3');
      gearDemo = new GearAnimation(g3, 5, 52, 24);
      initZoomPan(g3.createLayer(), g3, function(){g3.redrawAnimation;});

      g4 = new Cango('cvs4');
      intGearDemo = new IntGearAnimation(g4, 5, 42, 22, 20);
      initZoomPan(g4.createLayer(), g4, function(){g4.redrawAnimation;});
    }

    function showConstruction()
    {
      invDiagram.showConst = !invDiagram.showConst;
      invDiagram.drawInv();
      return false;
    }

    var consoleBtns3 =
    {
      f1:function(){gearDemo.run()},
      f2:function(){gearDemo.halt()}
    };

    var consoleBtns4 =
    {
      f1:function(){intGearDemo.run()},
      f2:function(){intGearDemo.halt()}
    };
  &lt;/script&gt;</t>
<t tx="leo.20170509173005.6">/*=====================================================================
  Filename: CangoAnimation-5v00.js
  Rev 5
  By: A.R.Collins
  Description:  This file augments the core Cango object with
                animation methods
  License: Released into the public domain
  latest version at
  &lt;http://www/arc.id.au/&gt;

  Date    Description                                             |By
  --------------------------------------------------------------------
  11May14 First release                                            ARC
  21Jul14 Updated to Cango-5 _buf becomes this.cnvs.buf            ARC
  24Jul14 Enable synchronised timeline for all layers
          Released as Version 2                                    ARC
  14Nov15 Dropped non-functional references to duration=0
          Rename Timeline to CgoTimeline to avoid conflicts        ARC
  16Nov15 Allow any path function, not just interpolate            ARC
  17Nov15 Add standard interpolateKeyFrames path function          ARC
          Let Timeline handle saving draw time as currState.time   ARC
  20Nov15 Support calling clipPath in pathFn (requires Cango7v16)  ARC
  22Nov15 rename 'interpolateKeyFrmaes' to 'interpolate',
          use x,y,scl,rot not xKeyFrames etc.
          Call render(obj, nextState) immediatley after initFn
          Make currState clone of nextState after initFn called    ARC
  23Nov15 Add support for ketTimes in interpolate
          Added optional start offset from paused                  ARC
  24Nov15 Change mode to STOPPED after duration time (not pause)   ARC
  28Nov15 Add resetClip after render in Animation instantiation
          ctx.save before pathFn call and ctx.restore after render ARC
  01Dec15 Released as 3v00 (based on 3beta-19)                     ARC
  17Dec15 bugfix: resume from stop didn't set currState.time=0.
          deleteAnimation forces timeline to paused mode           ARC
  21Jan16 bugfix: resetClip called after buffer switch             ARC
  02Feb16 Add Tweener utility, drop interpolate
          Release as Version 4  (based on 4beta-01)                ARC
  13Feb16 Define animation keyTimes in percentage of duration      ARC
  12Mar17 Update to use Cango Ver 9
          Don't assume nextState properties except time            ARC
  25Mar17 Add drawFn to Animation parameters to match Timeline     ARC
  26Mar17 bugfix: restore ctx after render                         ARC
  30Mar17 Released as CangoAnimation-5v00                          ARC
 =====================================================================*/

var CgoTimeline, Tweener;

Cango = (function(CangoCore)  // Cango must be declared a global before this file is loaded
{
  "use strict";

  if (!Date.now)
  {
    Date.now = function now()
    {
      return new Date().getTime();
    };
  }

  var isArray = function(obj)
  {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  var isNumber = function(o)
  {
    return !isNaN(o) &amp;&amp; o !== null &amp;&amp; o !== "" &amp;&amp; o !== false;
  };

  Tweener = function(delay, duration, loopStr)    // a pre-defined pathFn
  {
		this.delay = delay || 0;
    this.dur = duration || 5000;
    this.reStartOfs = 0;
    this.loop = false;
    this.loopAll = false;

    var savThis = this,
        loopParm = "noloop";

    if (typeof loopStr === 'string')
    {
      loopParm = loopStr.toLowerCase();
    }
    if (loopParm === 'loop')
    {
      this.loop = true;
    }
    else if (loopParm === 'loopall')
    {
      this.loopAll = true;
    }

    this.getVal = function(time, vals, keyTimes)  // vals is an array of key frame values (or a static number)
    {
      var numSlabs, slabDur, slab, frac, i,
					t = 0,
					tFrac,
					localTime,
					values, times;

      if (time === 0)       // re-starting after a stop, otherwise this can increase forever (looping is handled here)
      {
        savThis.reStartOfs = 0;     // reset this to prevent negative times
      }
      localTime = time - savThis.reStartOfs;       // handles local looping
      if ((localTime &gt; savThis.dur+savThis.delay) &amp;&amp; (savThis.dur &gt; 0) &amp;&amp; (savThis.loop || savThis.loopAll))
      {
        savThis.reStartOfs = savThis.loop? time - savThis.delay : time;      // we will correct external time to re-start
        localTime = 0;          // force re-start at frame 0 now too
      }
      t = 0;    // t is the actual local time value used for interpolating
      if (localTime &gt; savThis.delay)    // repeat initial frame (t=0) if there is a delay to start
      {
        t = localTime - savThis.delay;   // localTime is contrained to 0 &lt; localTime &lt; this.dur
      }

      if (!isArray(vals))    // not an array, just a static value, return it every time
      {
        return vals;
      }
      if (!vals.length)
      {
        return 0;
      }
      if (vals.length === 1)
      {
        return vals[0];
      }
      // we have at least 2 element array of values
      if (t === 0)
      {
        return vals[0];
      }
      if (t &gt;= savThis.dur)
      {
        return vals[vals.length-1];  // freeze at end value
      }
      numSlabs = vals.length-1;
      if (!isArray(keyTimes) || (vals.length !== keyTimes.length))
      {
        slabDur = savThis.dur/numSlabs;
        slab = Math.floor(t/slabDur);
        frac = (t - slab*slabDur)/slabDur;

        return vals[slab] + frac*(vals[slab+1] - vals[slab]);
      }

      // we have keyTimes to play work with copies of arrays
      values = [].concat(vals);
      times = [].concat(keyTimes);
      // make sure times start with 0
      if (times[0] !== 0)
      {
        values.unshift(values[0]);
        times.unshift(0);
      }
      // make sure times end with 100
      if (times[times.length-1] !== 100)
      {
        values.push(values[values.length-1]);
        times.push(100);
      }
      i = 0;
      tFrac = t/savThis.dur;
      while ((i &lt; times.length-1) &amp;&amp; (times[i+1]/100 &lt; tFrac))
      {
        i++;
      }
      slabDur = (times[i+1]-times[i])/100;
      frac = (tFrac - times[i]/100)/slabDur;    // convert percentage time to fraction

      return values[i] + frac*(values[i+1] - values[i]);
    };
  };

  function Animation(id, gc, obj, initFn, drawFn, pathFn, options)
  {
    var prop;

    this.id = id;
    this.gc = gc;        // the Cango context to do the drawing
    this.obj = obj;
    this.drawFn = drawFn;
    this.pathFn = pathFn;    // root object (Obj2D or Group2D) of scene to be draw
    this.options = options;
    this.currState = {time:0};
    this.nextState = {time:0};
    this.gc.ctx.save();
    if (typeof initFn === "function")
    {
      initFn.call(this, options);  // call object creation code
    }
    // draw the object as setup by initFn (pathFn not called yet)
    if (typeof this.drawFn === "function")
    {
      this.drawFn.call(this, this.obj, this.nextState, options);   // call user custom function
    }
    else
    {
      this.gc.render(this.obj, this.nextState);     // call default draw function
    }
    this.gc.resetClip();    // if init calls clipPath, it must be reset so next frame doesn't combine clip areas
    this.gc.ctx.restore();  // if initFn makes changes to ctx restore to pre-initFn state
    // now it has been drawn save the currState values (nextState values are generated by pathFn)
    for (prop in this.nextState)   // if initFn creates new properties, make currState match
    {
      if (this.nextState.hasOwnProperty(prop))
      {
        this.currState[prop] = this.nextState[prop];
      }
    }
  }

  // this is the actual animator that draws the frame
  function drawFrame(timeline)
  {
    var temp, i, at,
        prevAt = null,
        localTime,
        time = Date.now();    // use this as a time stamp, browser don't all pass the same time code

    if (timeline.prevAnimMode === timeline.modes.STOPPED)
    {
      timeline.startTime = time - timeline.startOfs;    // forces localTime = 0, start from beginning
    }
    localTime =  time - timeline.startTime;

    // step through all the animation tasks
    for (i=0; i&lt;timeline.animTasks.length; i++)
    {
      at = timeline.animTasks[i];
      if (at.gc.cId !== prevAt)
      {
        // check for new layer, only clear a layer once, there maybe several Cango contexts on each canvas
        at.gc.clearCanvas();
        prevAt = at.gc.cId;
      }
      at.gc.ctx.save();
      // if re-starting after a stopAnimation reset the currState.time so pathFn doesn't get negative time between frames
      if (timeline.prevAnimMode === timeline.modes.STOPPED)
      {
        at.currState.time = 0;    // avoid -ve dT (=localTime-currState.time) in pathFn
      }
      if (typeof(at.pathFn) === 'function')  // static objects may have null or undefined
      {
        at.pathFn.call(at, localTime, at.options);
      }
      if (typeof at.drawFn === "function")
      {
        at.drawFn.call(at, at.obj, at.nextState, at.options);  // call user custom function
      }
      else
      {
        at.gc.render(at.obj, at.nextState);     // default draw function
      }
      at.gc.ctx.restore(); // if pathFn changes any ctx properties restore to pre pathFn state
      // now swap the currState and nextState vectors (pathFn may use currState to gen nextState)
      temp = at.currState;
      at.currState = at.nextState; // save current state vector, pathFn will use it
      at.nextState = temp;
      // save the draw time for pathFn
      at.currState.time = localTime;
    }
    timeline.currTime = localTime;      // timestamp of what is currently on screen
  }

  CgoTimeline = function()
  {
    this.animTasks = [];    // each layer can push an Animation object in here
    this.timer = null;                // need to save the rAF id for cancelling
    this.modes = {PAUSED:1, STOPPED:2, PLAYING:3, STEPPING:4};     // animation modes
    this.animMode = this.modes.STOPPED;
    this.prevAnimMode = this.modes.STOPPED;
    this.startTime = 0;               // Date.now when localTime was 0 used to generate localTime
    this.startOfs = 0;                // used if play calls with non-zero start time
    this.currTime = 0;                // time along timeline (starting at 0) of frame on screen
    this.stepTime = 50;               // animation step time interval (in msec)
  };

  CgoTimeline.prototype.stopAnimation = function()
  {
    window.cancelAnimationFrame(this.timer);
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.STOPPED;
    // reset the currTime so play and step know to start again
    this.currTime = 0;
    this.startOfs = 0;
  };

  CgoTimeline.prototype.pauseAnimation = function()
  {
    window.cancelAnimationFrame(this.timer);
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.PAUSED;
  };

  CgoTimeline.prototype.stepAnimation = function()
  {
    var savThis = this;

    // this is the actual animator that draws the frame
    function drawIt()
    {
      drawFrame(savThis);
      savThis.prevAnimMode = savThis.modes.PAUSED;
      savThis.animMode = savThis.modes.PAUSED;
    }

    // eqivalent to play for one frame and pause
    if (this.animMode === this.modes.PLAYING)
    {
      return;
    }
    if (this.animMode === this.modes.PAUSED)
    {
      this.startTime = Date.now() - this.currTime;  // move time as if currFrame just drawn
    }
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.STEPPING;

    setTimeout(drawIt, this.stepTime);
  };

  CgoTimeline.prototype.redrawAnimation = function()
  {
    // eqivalent to play for one frame and pause
    if (this.animMode === this.modes.PLAYING)
    {
      return;
    }
    this.startTime = Date.now() - this.currTime;  // move time as if currFrame just drawn

    drawFrame(this);
  };

  CgoTimeline.prototype.playAnimation = function(startOfs, stopOfs)
  {
    var savThis = this;

    function drawIt()
    {
      drawFrame(savThis);
      savThis.prevAnimMode = savThis.modes.PLAYING;
      if (stopOfs)
      {
        if (savThis.currTime &lt; stopOfs)
        {
          savThis.timer = window.requestAnimationFrame(drawIt);
        }
        else
        {
          savThis.stopAnimation();     // go back to start of time line
        }
      }
      else
      {
        savThis.timer = window.requestAnimationFrame(drawIt);   // go forever
      }
    }

    this.startOfs = startOfs || 0;
    if (this.animMode === this.modes.PLAYING)
    {
      return;
    }
    if (this.animMode === this.modes.PAUSED)
    {
      this.startTime = Date.now() - this.currTime;  // move time as if currFrame just drawn
    }
    this.prevAnimMode = this.animMode;
    this.animMode = this.modes.PLAYING;

    this.timer = window.requestAnimationFrame(drawIt);
  };

//===============================================================================

  CangoCore.prototype.animate = function(obj, init, draw, path, options)
  {
    var animObj,
        animId;

    animId = this.cId+"_"+this.getUnique();
    animObj = new Animation(animId, this, obj, init, draw, path, options);
    // push this into the Cango animations array
    this.stopAnimation();   // make sure we are not still running and old animation
    this.bkgCanvas.timeline.animTasks.push(animObj);

    return animObj.id;   // so the animation just created can be deleted if required
  };

  CangoCore.prototype.pauseAnimation = function()
  {
    this.bkgCanvas.timeline.pauseAnimation();
  };

  CangoCore.prototype.playAnimation = function(startTime, stopTime)
  {
    this.bkgCanvas.timeline.playAnimation(startTime, stopTime);
  };

  CangoCore.prototype.stepAnimation = function()
  {
    this.bkgCanvas.timeline.stepAnimation();
  };

  CangoCore.prototype.stopAnimation = function()
  {
    this.bkgCanvas.timeline.stopAnimation();
  };

  CangoCore.prototype.redrawAnimation = function()
  {
    this.bkgCanvas.timeline.redrawAnimation();
  };

  CangoCore.prototype.deleteAnimation = function(animId)
  {
    var idx = -1,
        i;

    this.pauseAnimation();   // pause all animations
    for (i=0; i&lt;this.bkgCanvas.timeline.animTasks.length; i++)
    {
      if (this.bkgCanvas.timeline.animTasks[i].id === animId)
      {
        idx = i;
        break;
      }
    }
    if (idx === -1)
    {
      // not found
      return;
    }
    this.bkgCanvas.timeline.animTasks.splice(idx,1);       // delete the animation object
  };

  CangoCore.prototype.deleteAllAnimations = function()
  {
    this.stopAnimation();
    this.bkgCanvas.timeline.animTasks = [];
  };

  return CangoCore;    // return the augmented Cango object, over-writing the existing

}(Cango));     // Take the existing Cango object and add animation methods
</t>
<t tx="yen.20170108171605.1"></t>
<t tx="yen.20170108171605.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="yen.20170108171605.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="yen.20170108171622.1">2017 Spring CD 機械設計工程系協同產品設計實習

倉儲位置: https://github.com/mdecourse/2017springcd

每一協同成員都應該要在 users 目錄下有一個 Leo 檔案

</t>
<t tx="yen.20170108171733.1"></t>
<t tx="yen.20170108171733.2">@language python
import os
#os.system("pelican content -o output -s local_publishconf.py -t theme/pelican-bootstrap3")
os.system("pelican content -o blog -s local_publishconf.py")
g.es("admin pelican 近端執行完畢")


</t>
<t tx="yen.20170108171733.5"></t>
<t tx="yen.20170108171733.71"></t>
<t tx="yen.20170108171733.81"></t>
<t tx="yen.20170108171733.83">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt

</t>
<t tx="yen.20170108171930.1">@language python
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 7443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("7443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="yen.20170108171939.1">@language python
import os
import subprocess
import threading
import socket
import http.server, ssl

class HTTPServerV6(http.server.HTTPServer):
    address_family = socket.AF_INET6
  
def domake():
    # build directory
    os.chdir("./../")
    ipv6_address = '2001:288:6004:17:3004::808'
    server_address = (ipv6_address, 6443)
    #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("6443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="yen.20170120110024.1">@language xml
@tabwidth -4
@others

</t>
<t tx="yen.20170120110024.2">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
@others
&lt;/html&gt;
</t>
<t tx="yen.20170120110024.3">&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
&lt;title&gt;
2017 Spring 機械設計工程系協同產品設計實習
&lt;/title&gt;
    &lt;meta name="description" content="A framework for easily creating beautiful presentations using HTML"&gt;
    &lt;meta name="author" content="Hakim El Hattab"&gt;
    
    &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt;
    &lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"&gt;
    
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;
    
    &lt;link rel="stylesheet" href="https://cad-lab.github.io/cadlab_data/reveal/css/reveal.css"&gt;
    &lt;link rel="stylesheet" href="https://cad-lab.github.io/cadlab_data/reveal/css/theme/black.css" id="theme"&gt;
    
    &lt;!-- Theme used for syntax highlighting of code --&gt;
    &lt;link rel="stylesheet" href="https://cad-lab.github.io/cadlab_data/reveal/lib/css/zenburn.css"&gt;

    &lt;!-- Printing and PDF exports --&gt;
    &lt;script&gt;
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://cad-lab.github.io/cadlab_data/reveal/css/print/pdf.css' : 'https://cad-lab.github.io/cadlab_data/reveal/css/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    &lt;/script&gt;

    &lt;!--[if lt IE 9]&gt;
    &lt;script src="https://cad-lab.github.io/cadlab_data/reveal/lib/js/html5shiv.js"&gt;&lt;/script&gt;
    &lt;![endif]--&gt;
&lt;/head&gt;

</t>
<t tx="yen.20170120110024.4">&lt;body&gt;
@others
&lt;script src="https://cad-lab.github.io/cadlab_data/reveal/lib/js/head.min.js"&gt;&lt;/script&gt;
&lt;script src="https://cad-lab.github.io/cadlab_data/reveal/js/reveal.js"&gt;&lt;/script&gt;
&lt;script&gt;
        // More info https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            transition: 'slide', // none/fade/slide/convex/concave/zoom

            // More info https://github.com/hakimel/reveal.js#dependencies
            dependencies: [
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/zoom-js/zoom.js', async: true },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/notes/notes.js', async: true },
                { src: 'https://cad-lab.github.io/cadlab_data/reveal/plugin/math/math.js', async: true }
            ]
        });
&lt;/script&gt;
&lt;/body&gt;
</t>
<t tx="yen.20170120110024.5">&lt;div class="reveal"&gt;
@others
&lt;/div&gt;

</t>
<t tx="yen.20170120212350.1"></t>
<t tx="yen.20170209024032.1">https://studywolf.wordpress.com/

https://github.com/studywolf/blog/tree/master/VREP

https://www.youtube.com/channel/UCiK0J5wtnyX2jP-AiGbdhjg

V-rep

http://www.cnblogs.com/21207-iHome/tag/V-rep/</t>
<t tx="yen.20170215103217.1"></t>
<t tx="yen.20170215103228.1"></t>
</tnodes>
</leo_file>
